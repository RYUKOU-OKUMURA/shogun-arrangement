# ADR-001: マルチエージェントオーケストレーションアーキテクチャの採用

## 日付
2026-02-03

## ステータス
承認済み

## コンテキスト（背景・課題）

### 問題
- AI駆動開発において、単一のAIエージェントでは複雑なタスクを効率的に処理できない
- タスクの並列実行、役割分担、進捗管理が必要
- チーム開発のように複数のエージェントが協調して作業する仕組みが求められている

### 技術的背景
- Claude Codeのマルチセッション機能を活用可能
- tmuxによるセッション管理が利用できる
- YAMLファイルによる非同期通信が実現可能

### ビジネス的背景
- 開発タスクの効率化が求められている
- チーム全体でAIを活用する仕組みが必要
- 人間の監視下でAIが自律的に作業する環境が望ましい

## 決定（What We Will Do）

**サッカーチームスタイルのマルチエージェントオーケストレーションアーキテクチャを採用する。**

具体的には：

1. **階層構造**: ディレクター → キャプテン → プレイヤーの3階層
2. **通信方式**: YAMLファイル + tmux send-keysによる非同期通信
3. **役割分担**:
   - ディレクター: 戦略的計画（タスク分解、役割割り当て）
   - キャプテン: 調整者（指示の中継、進捗監視）
   - プレイヤー: 実行者（実際の作業）
4. **並列実行**: 複数のプレイヤーが同時に独立したタスクを実行

## システムアーキテクチャ図

```
ユーザー（ボス）
    │
    ▼ 指示
┌──────────────┐
│   ディレクター  │  ← 戦略的計画者（タスク分解、役割割り当て）
└──────┬───────┘
       │ YAML + send-keys
       ▼
┌──────────────┐
│   キャプテン   │  ← 調整者（指示の中継、進捗監視）
└──────┬───────┘
       │ YAML + send-keys
       ▼
┌───────┬───────┬───────┐
│プレイヤー1│プレイヤー2│プレイヤー3│  ← 実行者（実際の作業）
└───┬───┴───┬───┴───┬───┘
    │       │       │
    ▼       ▼       ▼
  タスク    タスク    タスク     ← サブエージェント（必要に応じてTaskツール経由）
  ツール    ツール    ツール
```

## 検討した代替案

### 選択肢A: 単一エージェント方式
- **メリット**:
  - 実装が簡単
  - 通信オーバーヘッドがない
- **デメリット**:
  - 並列実行ができない
  - タスクが複雑になると処理しきれない
  - 進捗管理が困難

### 選択肢B: フラットなピアツーピア方式
- **メリット**:
  - すべてのエージェントが対等
  - 柔軟な協調が可能
- **デメリット**:
  - 誰が何をするか不明確になりがち
  - 衝突の調整が複雑
  - 進捗管理が困難

### 選択肢C: 階層型マルチエージェント方式（採用）
- **メリット**:
  - 明確な役割分担
  - 効率的な並列実行
  - 進捗管理が容易
  - 人間のチーム開発に近いモデル
- **デメリット**:
  - 実装複雑度が高い
  - 通信レイテンシが発生する

## 結果（Consequences）

### ポジティブな結果

- **並列処理**: 複数のプレイヤーが同時に作業可能
- **役割分担**: 各エージェントの責務が明確
- **進捗管理**: キャプテンが全体の進捗を把握
- **スケーラビリティ**: プレイヤー数を容易に増減可能
- **人間監視**: すべての通信がYAMLファイルで追跡可能

### ネガティブな結果

- **通信レイテンシ**: YAMLファイル + tmux経由で通信するため遅延がある
- **実装複雑度**: 初期セットアップと管理が複雑
- **学習コスト**: 新メンバーがアーキテクチャを理解する必要がある

### 中立的な結果

- ディレクトリ構造が階層的になる（director/, captain/, player{N}/）
- 通信プロトコルが独自のものになる

## 通信プロトコル

### 通信フロー

1. **ユーザー → ディレクター**: ディレクターセッションでの直接入力
2. **ディレクター → キャプテン**: `queue/director_to_captain.yaml`に書き込み、その後send-keys
3. **キャプテン → プレイヤー**: `queue/captain_to_players/player{N}.yaml`に書き込み、その後send-keys
4. **プレイヤー → キャプテン**: タスク完了後にsend-keysで通知
5. **キャプテン → ディレクター**: `dashboard.md`を更新

### 重要：send-keysは2つの別々の呼び出しである必要があります！

```bash
# 間違い：結合（Enterが正しく解析されない）
tmux send-keys -t captain:0.0 'message' Enter

# 正しい：別々の呼び出し
tmux send-keys -t captain:0.0 'message'
tmux send-keys -t captain:0.0 Enter
```

## ディレクトリ構造

```
tmux-parallel-core/
├── start.sh                           # メイン起動スクリプト
├── init.sh                            # 初期セットアップ
├── dashboard.md                       # 進捗ダッシュボード
├── project/                           # 共有プロジェクトファイル
│
├── docs/                              # ドキュメント
│   ├── adr/                           # Architecture Decision Records
│   ├── PHASE_01_IDEA.md               # 9フェーズ開発フロー
│   └── ...
│
├── director/
│   └── agents.md                      # ディレクターの指示
│
├── captain/
│   └── agents.md                      # キャプテンの指示
│
├── player1/
│   ├── agents.md                      # プレイヤー1の指示
│   ├── project -> ../project          # 共有プロジェクトへのシンボリックリンク
│   └── specs/                         # 設計ドキュメント
│
├── player2/
│   └── ...
│
├── player3/
│   └── ...
│
└── queue/
    ├── director_to_captain.yaml       # ディレクター → キャプテンへのコマンド
    └── captain_to_players/
        ├── player1.yaml               # キャプテン → プレイヤー1へのタスク
        ├── player2.yaml               # キャプテン → プレイヤー2へのタスク
        └── player3.yaml               # キャプテン → プレイヤー3へのタスク
```

## セッション参照

| 役割 | セッション | ペイン |
|------|-----------|-------|
| ディレクター | director | 0 |
| キャプテン | captain | 0 |
| プレイヤー1 | players | 0 |
| プレイヤー2 | players | 1 |
| プレイヤー3 | players | 2 |

## 重要な概念

### イベント駆動（ポーリングなし）

- 応答を待つためにループを使用しない
- 常にYAMLファイル + send-keys通知を使用する
- これによりAPIクレジットを節約

### 階層構造

- **ディレクター**: ユーザーのコマンドを受け取り、タスクを分解し、役割を割り当てる
- **キャプテン**: プレイヤーに指示を中継し、進捗を監視する
- **プレイヤー**: タスクを実行し、Taskツール経由でサブエージェントを生成できる

### サブエージェント（Taskツール）

プレイヤーはClaude CodeのTaskツールを使用して、以下のためにサブエージェントを生成できます：
- 複雑なサブタスク
- 並列独立作業
- コードレビュー
- テスト実行

### 競合状態の防止

- 各プレイヤーは専用のタスクファイルを持つ
- 2つのプレイヤーが同じファイルに書き込むことはない

## 信頼度
高

このアーキテクチャはプロジェクトの要件に適しており、実装も進んでいます。
ただし、スケーラビリティについてはさらに検証が必要です。
