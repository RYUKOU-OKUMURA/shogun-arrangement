# ADR-003: 品質ゲートの自動化とテストピラミッド戦略

## 日付
2026-02-03

## ステータス
承認済み

## コンテキスト（背景・課題）

### 問題
- 品質基準が人によってバラバラ
- 手動での品質チェックは漏れが発生する
- テスト戦略が明確でない
- Flakyテストが信頼性を損なっている

### 技術的背景
- CI/CDパイプラインが構築可能
- 静的解析ツールが充実している
- テストフレームワーク（Jest, Playwright）が利用可能

### ビジネス的背景
- 品質の担保が顧客満足度に直結
- 手戻りコストを削減したい
- デプロイ頻度を上げたい

## 決定（What We Will Do）

**品質ゲートの自動化とテストピラミッド戦略を採用する。**

具体的には：

1. **CI/CDパイプライン**:
   - フォーマットは自動化
   - CIでFailしたらマージ不可（例外なし）
   - 段階的テスト実行

2. **テストピラミッド戦略**:
   - ユニットテスト（基盤、最多）
   - 統合テスト（中間層）
   - E2Eテスト（最上層、最少）

3. **品質基準**:
   - テストカバレッジ: 最低80%
   - lint: 必須
   - typecheck: 必須
   - test: 必須

4. **Flakyテスト対策**:
   - 最優先で潰す
   - 時刻・乱数・外部I/Oは固定 or 注入

## テストピラミッド

```
      /\
     /E2E\      ← 少数：重要なユーザーフローのみ
    /------\
   /統合Test\   ← 中程度：コンポーネント間の連携
  /----------\
 /ユニットTest\ ← 多数：個別機能の検証（基盤）
/--------------\
```

### なぜこの形が重要か

- **ユニットテスト**: 高速、安定、メンテしやすい
- **E2Eテスト**: 遅い、不安定、メンテが困難
- **下の層でテストできることは下でテストする**（効率優先）

### 各層の役割

#### ユニットテスト（基盤、最多）
- 個別の関数・メソッドを高速にテスト
- カバレッジは高く保つ
- TDD（Test-Driven Development）の実践推奨

#### 統合テスト（中間層）
- コンポーネント間の連携を検証
- 外部依存（DB、API等）との連携

#### E2Eテスト（最上層、最少）
- ユーザー視点での重要なフローのみ
- 実行コストが高いため数を絞る

#### 原則
- **現実に起こり得ることは網羅的に**
- **起こり得ないことは書いても無駄**

## CI/CDパイプライン

### フォーマットは自動化する

```bash
# pre-commit / lefthook / husky 等
pre-commit run --all-files
```

- コミット前に自動整形
- 手動の手間を削減

### CIでFailしたらマージ不可

- 例外を作らない（運用が壊れる）
- ステータスチェック必須化
- 全テストパス + lint通過 + typecheck通過が必須

### 段階的テスト実行

| タイミング | テスト種類 |
|-----------|-----------|
| PR作成時 | ユニットテスト + lint |
| マージ前 | 統合テスト |
| デプロイ前 | E2Eテスト |

## Flakyテストの撲滅

### なぜFlakyテストは最優先で潰すべきか

- テストが信頼されなくなる
- CI/CDのボトルネックになる
- 開発者の時間を奪う

### Flakyテスト防止策

1. **時刻・乱数・外部I/Oは固定 or 注入**
   - Clockモック
   - Randomモック
   - HTTPモック

2. **並列実行時の競合状態に注意**
   - テストの独立性を保つ
   - 共有リソースの排他制御

3. **非決定的な動作を排除**
   - タイミングに依存しないテスト
   - 順序に依存しないテスト

4. **テストの独立性を保つ**
   - 各テストは他のテストに依存しない
   - クリーンな状態で開始

## 品質ゲート

### コード品質

| 項目 | 基準 | 必須/推奨 |
|------|------|---------|
| テストカバレッジ | 最低80% | 必須 |
| lint | エラーなし | 必須 |
| typecheck | エラーなし | 必須 |
| test | 全パス | 必須 |
| PRあたりの行数 | 200行未満 | 推奨 |

### レビュー待ち時間

| メトリクス | 目標 |
|-----------|------|
| レビュー待ち時間 | < 2時間 |
| PRライフサイクル | < 1日 |
| 不安定なテスト率 | < 1% |

## AAAパターン（Arrange–Act–Assert）

テストコードは **3つの区切り**で書く：

```typescript
// Arrange（準備）：前提・入力・モックなどを用意
const input = { value: 10 };
const mock = jest.fn();

// Act（実行）：対象コードを呼び出す
const result = functionUnderTest(input);

// Assert（検証）：結果が期待どおりか確認
expect(result).toBe(20);
expect(mock).toHaveBeenCalled();
```

### なぜ必要か

- テストの可読性が上がる
- テストの意図が明確になる
- メンテナンスしやすくなる

## CODEOWNERS

責任範囲を明確化する：

```
# データベース関連
/db/ @database-team

# フロントエンド
/frontend/ @frontend-team

# セキュリティ重要箇所
/auth/ @security-team
```

### なぜ必要か

- レビューが安定する
- 適切な専門家が必ずレビュー
- 責任範囲が明確

## 検討した代替案

### 選択肢A: 手動品質チェック
- **メリット**:
  - ツール導入のコストがない
- **デメリット**:
  - 漏れが発生する
  - 品質が人によってバラつく
  - 時間がかかる

### 選択肢B: 自動化のみ（テストピラミッドなし）
- **メリット**:
  - 実装が簡単
- **デメリット**:
  - テスト戦略が不明確
  - E2Eテストが多くなりがち
  - テスト実行時間が長くなる

### 選択肢C: 自動化 + テストピラミッド（採用）
- **メリット**:
  - 品質が担保される
  - 効率的なテスト戦略
  - テスト実行時間が短い
  - 信頼性が高い
- **デメリット**:
  - 初期セットアップのコスト
  - テストを書く習慣が必要

## 結果（Consequences）

### ポジティブな結果

- **品質の担保**: 自動化された品質ゲートにより品質が担保される
- **手戻りの削減**: 早期に問題が発見される
- **デプロイ頻度の向上**: 品質への信頼によりデプロイが容易になる
- **テストの信頼性**: Flakyテスト排除によりテストが信頼される

### ネガティブな結果

- **初期コスト**: CI/CDパイプラインの構築が必要
- **テスト作成コスト**: テストを書く時間が必要
- **学習コスト**: チームがテストピラミッドを理解する必要がある

### 中立的な結果

- 各PRでテストが実行される
- テストコードの量が増える

## 信頼度
高

これは広く採用されているベストプラクティスであり、品質担保に効果的です。
