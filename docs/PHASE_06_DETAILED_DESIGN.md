# Phase 6: 詳細設計 (Detailed Design)

## 目的

実装の詳細を決定し、AIへの道標を作る。

## なぜ必要か

### ライブラリ選定を誤ると後で変更できない

- 依存関係が複雑に絡む
- 全体を書き直しになる
- 移行コストが膨大

### AIへの指示が曖昧だとハルシネーション多発

- ルールがない → 好き勝手に実装
- 道標がない → token無駄遣い
- 一貫性がない → コードの品質がバラバラ

### 静的解析を決めないと品質が安定しない

- AIの判断に任せると抜けが出る
- ルールで縛って均一な品質に
- 自動化しないと人的ミスが発生

### テスト範囲を決めないと無駄か不足が起こる

- 全部テスト → 時間の無駄、メンテナンスコスト増
- 一部だけテスト → バグ見逃し、品質低下
- テストをすると品質も上がる

## 何をするか

### 1. ライブラリを決める

- 製品を完成させるための道具
- バージョン、ライセンス、メンテナンス状況を確認
- コミュニティの活発さ
- セキュリティアップデートの頻度

### 2. 最適化・ルール・エージェント.md・skill・MCPを調整

- AIの道標を作る
- ハルシネーション防止
- 必要最低限のtokenで動く設計
- 一貫性のある出力を保証

### 3. 静的解析ツールを決める

- lint、formatter、type checker
- AIで判断すると抜けがある部分を徹底
- 自動化で品質を担保
- pre-commitフックで自動実行

### 4. テストカバレッジ範囲を決める（テストピラミッド戦略）

#### ユニットテスト（基盤、最多）
- 個別の関数・メソッドを高速にテスト
- カバレッジは高く保つ
- TDD（Test-Driven Development）の実践推奨

#### 統合テスト（中間層）
- コンポーネント間の連携を検証
- 外部依存（DB、API等）との連携

#### E2Eテスト（最上層、最少）
- ユーザー視点での重要なフローのみ
- 実行コストが高いため数を絞る

#### 原則
- 現実に起こり得ることは網羅的に、起こり得ないことは書いても無駄

#### 注意
- 逆ピラミッド（アイスクリームコーン型）にならないよう注意

### 5. 詳細設計は1つずつ作る

- 設計を分けても、詳細設計を作るのは作業する1つのみ
- 手戻り防止
- フォーカスを維持

### 6. 前回の詳細設計をコンテキストに加える

- 設計のブレを減らす
- 一貫性を保つ
- 過去の判断を参照

### 7. 「なぜ」を明記する

- それでないといけない理由
- 無駄な設計、コードは手戻り原因
- 設計の大原則

## テストピラミッドの重要性

```
      /\
     /E2E\      ← 少数：重要なユーザーフローのみ
    /------\
   /統合Test\   ← 中程度：コンポーネント間の連携
  /----------\
 /ユニットTest\ ← 多数：個別機能の検証（基盤）
/--------------\
```

### なぜこの形が重要か

- ユニットテスト: 高速、安定、メンテしやすい
- E2Eテスト: 遅い、不安定、メンテが困難
- 下の層でテストできることは下でテストする（効率優先）

### 失敗例（逆ピラミッド）

- E2Eテストが多すぎる
- 実行に時間がかかる
- 不安定で頻繁に失敗
- メンテナンスコスト大
- 結果: テストが信頼されなくなる

## チェックリスト

### 完了基準

- [ ] ライブラリが決まっているか？
- [ ] 静的解析ツールが設定されているか？
- [ ] テスト範囲が明確か（テストピラミッド）？
- [ ] 「なぜ」が明記されているか？
- [ ] 前回設計を参照しているか？
- [ ] AIへのルール・道標が整っているか？

### 出力物

- 詳細設計書
- ライブラリ選定ドキュメント
- テスト計画
- コーディング規約

## 次のフェーズへの移行条件

- チェックリストの全項目が完了している
- 実装に必要な全てが決定されている
- AIへの指示が明確になっている

## 参考リソース

- [Practical Test Pyramid - Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html)
- ライブラリ公式ドキュメント
- コーディング規約のベストプラクティス
