# Phase 8: 実装 (Implementation)

## 目的

設計通りに実装し、品質の高いコードを書く。

## なぜ必要か

### ルールで縛らないと品質がバラバラ

- AIは自由度が高いと暴走する
- 統一感のないコードが生成される
- 保守性が低下

### いきなり実装すると無駄なコードが混入

- 検証せず動かす → 不要なifが大量
- クリーンでないコード → 保守性低下
- 要らないロジックで複雑化

### メモリ・CPU・DB負荷を考えないと遅くなる

- 取るデータ、残すデータは最低限に
- 早い = レスポンスが早い
- 回数が多ければ塵も積もる
- パフォーマンス問題は後から直すのが困難

### 副作用のある処理が散らばるとテストしづらい

- I/O処理を外側に、ビジネスロジックを内側に配置
- 純粋関数を増やすことでテスト可能性が向上

## 何をするか

### 1. ルールで縛る

- 決まったレールで動く
- 1つ1つを丁寧に作る
- 縛れば縛るほど良いコードを作る
- コーディング規約の徹底

### 2. まず関数をすべて作り、TODOをすべて記述

- すべてのタスクを完遂
- お残しをなくす
- 実装漏れを防ぐ

### 3. 複雑なロジックはまず検証から

- 検証せず動かしたコードは無駄なifで構成される
- 正しい動作を確認してから実装
- テストケースを先に書く（TDD）

### 4. 検証後もクリーンで最低限のコードを1度書く

- 要らないロジックを消す
- リファクタリング前提
- 可読性を優先

### 5. メモリ、CPU負荷、DB負荷は最低限に

- 取るデータ、残すデータは最低限に
- メモリ、CPU利用率は少なく早くする
- 早い = レスポンスが早くなる
- N+1問題の回避
- 不要なクエリの削減

### 6. 副作用は境界に寄せる

- I/O（DB/HTTP/ファイル等）は外側
- ロジックは内側へ
- テストしづらい設計を避ける

### 7. コーディング規約を守る

- ネストは浅く（早期return、分割、ガード節）
- 1行で書けることは1行で（可読性優先）
- 関数・変数名は意図が伝わる名前に
- エラー/例外の方針を統一

## テストの書き方（AAAパターン）

テストコードは **3つの区切り**で書く：

- **Arrange（準備）**：前提・入力・モックなどを用意
- **Act（実行）**：対象コードを呼び出す
- **Assert（検証）**：結果が期待どおりか確認

### なぜ必要か

- テストの可読性が上がる
- テストの意図が明確になる
- メンテナンスしやすくなる

## チェックリスト

### 完了基準

- [ ] ルールに従っているか？
- [ ] すべての関数が実装されているか？
- [ ] 複雑なロジックは検証済みか？
- [ ] クリーンなコードか？
- [ ] パフォーマンスを考慮しているか？
- [ ] 副作用は境界に寄せているか？
- [ ] テストはAAAパターンで書かれているか？

### 出力物

- 実装されたコード
- テストコード
- テスト結果レポート

## 次のフェーズへの移行条件

- チェックリストの全項目が完了している
- 全てのテストがパスしている
- lint / typecheckが通っている

## 参考リソース

- [AAAパターンの説明](https://martinfowler.com/bliki/GivenWhenThen.html)
- コーディング規約
- 既存のテストコード
