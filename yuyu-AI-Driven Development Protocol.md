# v1 開発のTips（AI駆動開発向け）

## このドキュメントは、チケット駆動・トランクベース前提で「小さく安全に進める」「AIが迷わずå動ける」ための実務Tipsをまとめたものです。

---

[AI協働開発・実験プロトコル (AI-Driven Development Protocol)](https://www.notion.so/AI-AI-Driven-Development-Protocol-b29f22a543c38364b27b01755a185298?pvs=21)

[TIPS: 設計書作成の事前準備（検索・参照ワークフロー）](https://www.notion.so/TIPS-506f22a543c383c1a298815fe7266624?pvs=21)

## 1. 開発フロー（チケット駆動 × トランクベース）

### 1.1 基本原則

- **1チケット = 1目的**
    - 仕様変更とリファクタは分ける（混ぜない）
- **Small PR原則**
    - 1PR=1意図、差分は小さく（理想は200行未満、最大でも400行程度）
    - レビューしやすく、マージしやすく、問題があれば戻しやすく
    - 研究によると200行未満のPRは、200行以上のPRを持つチームより40%多くのコードをデプロイできる
- **PR説明テンプレ（推奨）**
    - **目的（Why）**: なぜこの変更が必要か
    - **変更点（What）**: 何を変更したか
    - **テスト内容**: どうテストしたか
    - **影響範囲**: どこに影響があるか
    - **レビューガイド**: レビュアーがどの順序でファイルを見るべきか
    - **ロールバック**: 問題が起きた時の戻し方
- **段階的リリース**
    - Feature Flag や設定切り替えで「マージ＝即事故」を避ける
- **コミットは意味単位**
    - 変更理由が追える粒度で積む（AIも履歴で理解しやすい）
    - コミットメッセージは明確に（50文字以内の要約 + 詳細説明）

### 1.2 レビュープロセス

- **レビュー速度を優先**
    - PRが提出されたら2時間以内にレビュー開始（理想）
    - 最大でも1営業日以内に初回フィードバック
- **レビューの責任分担を明確化**
    - DRAFT状態：早期フィードバックを求める段階
    - READY FOR REVIEW：正式レビュー依頼
    - 専門性に応じたレビュアー割り当て（ドメイン専門家、セキュリティ専門家など）
- **建設的なフィードバック**
    - 「これは間違っている」ではなく「この部分について質問があります」
    - 可能な限り代替案やリソースを提示
    - 優れたPRは積極的に認める（モチベーション向上）

### 1.3 メトリクス計測

以下のメトリクスを追跡し、継続的改善に活用：

- **レビュー待ち時間**（Time to first review）
- **PRのライフサイクル**（作成からマージまでの時間）
- **アイドル時間**（誰も作業していない時間の割合）
- **再レビュー回数**（何度やり直しになったか）

---

## 2. 開発・単体テスト

### 2.1 テストピラミッド戦略

効率的なテスト戦略は**テストピラミッド**の形を維持する：

```
      /\
     /E2E\      ← 少数：重要なユーザーフローのみ
    /------\
   /統合Test\   ← 中程度：コンポーネント間の連携
  /----------\
 /ユニットTest\ ← 多数：個別機能の検証（基盤）
/--------------\

```

- **ユニットテスト**（基盤、最多）
    - 個別の関数・メソッドを高速にテスト
    - カバレッジは高く保つ（新機能追加時に常に作成）
    - TDD（Test-Driven Development）の実践推奨
- **統合テスト**（中間層）
    - コンポーネント間の連携、外部依存（DB、API等）を検証
    - ユニットテストではカバーできない実際の統合問題を検出
- **E2Eテスト**（最上層、最少）
    - ユーザー視点での重要なフローのみテスト
    - 実行コストが高いため数を絞る

**注意点**：

- 逆ピラミッド（アイスクリームコーン型）にならないよう注意
- E2Eテストが多すぎると遅く、不安定で、メンテナンスが困難になる
- 下の層でテストできることは下でテストする（効率優先）

### 2.2 AAAパターン（Arrange–Act–Assert）

テストコードを **3つの区切り**で書く作法です。

- **Arrange（準備）**：前提・入力・モックなどを用意
- **Act（実行）**：対象コードを呼び出す
- **Assert（検証）**：結果が期待どおりか確認

### 2.3 実用的なテストと網羅性

- カバー率は意識して高くする
- **起こり得るケースは全部テストする**
    - 正常系だけでなく、エッジケース、エラーケースも網羅
- モックも必要に応じて使う（やりすぎ注意）
    - 外部依存を分離してテストを高速化
    - ただし統合テストでは実際の依存関係でテストする
- **副作用のある処理は境界に寄せる**
    - テストしづらい設計を避け、純粋ロジックを増やす
    - I/O処理を外側に、ビジネスロジックを内側に配置

### 2.4 テストの運用ルール

- テストの責務を分ける：**Unit / Integration / E2E を混ぜない**
- **Flaky（不安定）を最優先で潰す**
    - 時刻・乱数・外部I/Oは固定 or 注入（Clock/Random/HTTPなど）
    - 並列実行時の競合状態に注意
    - 非決定的な動作を排除
- 失敗時に原因が分かるAssertを書く（検証粒度とメッセージを意識）
- テストのコメントアウトは最小限（必要な時のみ）
- **Shift Left**: 早期にテストを実行し、早期に問題を検出
    - ユニットテストは開発中に常時実行
    - 統合テストはマージ前に実行
    - E2Eテストはメインブランチマージ後、本番デプロイ前に実行

---

## 3. コードの書き方（可読性・保守性）

- **ネストは浅く**
    - 条件分岐が深いなら早期return、分割、ガード節を使う
- **1行で書けることは1行で**
    - ただし読みづらい短縮はしない（可読性優先）
- **関数・変数名は意図が伝わる名前に**
    - 何をするかが一目で分かる命名
    - 省略形は慎重に使う（一般的なもの以外は避ける）
- **副作用はできるだけ書かない**
    - I/O（DB/HTTP/ファイル等）は外側、ロジックは内側へ
    - 純粋関数を増やすことでテスト可能性が向上
- **エラー/例外の方針を統一する**
    - 例外で投げるのか、Resultで返すのか、層ごとに決める
    - 握りつぶさない、適切な粒度で処理する
- **ログの出し方を決める**
    - 「何を」「どの粒度で」「どの場面で」出すか統一する
    - 本番環境でのデバッグに必要な情報を残す
- **コードフォーマットの自動化**
    - Prettier、Black、gofmtなどを使い一貫性を保つ
    - pre-commitフックで自動実行

### 3.1 最適化・高速化・簡略化の判断基準

### いつ最適化すべきか / すべきでないか

Donald Knuthの有名な格言：「早すぎる最適化は諸悪の根源である」

**最適化すべき時**：

- **実測データに基づく場合のみ**
    - プロファイリングツールで実際のボトルネックを特定済み
    - ユーザーに影響が出ている（レスポンスが遅い、メモリ不足等）
    - パフォーマンス要件が明確で、現在それを満たしていない
- **アーキテクチャレベルの決定時**
    - システム全体のパフォーマンスはアーキテクチャ設計に圧倒的に影響される
    - 後から変更するとコスト大（初期設計で考慮すべき）
    - 例：データストレージの選択、通信プロトコル、並列処理モデル等

**最適化すべきでない時**：

- **推測・仮定に基づく場合**
    - 利用状況が不明確な段階での最適化は誤った方向への最適化になりがち
    - 「将来スケールするかもしれない」という理由だけで最適化しない
- **機能検証前の場合**
    - 100人のユーザーが製品を気に入っているか確認する前に、100万人対応の最適化をするのは時期尚早
    - まず正しい機能を作り、ユーザーフィードバックを得る
- **可読性・保守性を犠牲にする場合**
    - 最適化されたコードは複雑になりがちで、保守が困難になる
    - トレードオフを理解し、メリットがコストを上回る時のみ実行

### 最適化の判断フレームワーク

実装する前に以下を自問する：

1. **問題は明確か？**
    - 問題と様々な代替解決策について明確な理解があるか？
    - それとも問題空間が進化するのを待つべきか？
2. **投資対効果は？**
    - 投資が報われるまでの期間はどのくらいか？
    - 開発コストとパフォーマンス向上のバランスは取れているか？
3. **トレードオフは何か？**
    - 最適化により悪化するメトリクスは何か？
    - 可読性、保守性、開発速度への影響は？
4. **データはあるか？**
    - プロファイリング結果は？ボトルネックは特定済みか？
    - パフォーマンス監視ツールでメトリクスを計測しているか？
5. **代替案は検討したか？**
    - アルゴリズム変更、アーキテクチャ変更、スケールアウト等
    - マイクロ最適化より高レベルの改善の方が効果的な場合が多い

### 段階的な最適化アプローチ

1. **まず動くものを作る**（Make it work）
    - 正確性、テスト可能性を優先
2. **次に正しくする**（Make it right）
    - リファクタリングで可読性、保守性を向上
3. **必要なら高速化する**（Make it fast）
    - 計測し、ボトルネックを特定してから最適化

### AI使用時の注意点

- **AIに最適化させる前に「なぜ」を明示**
    - 「この処理が遅いから最適化して」ではなく
    - 「プロファイリング結果でこの関数が全体の60%の時間を占めている。O(n²)をO(n log n)に改善できないか検討して」
- **最適化と機能追加を分離**
    - 1PR=1目的の原則を守る
    - 最適化PRでは性能改善のみに集中
    - ベンチマーク結果をPR説明に含める

---

## 4. AIにやらせる際のルール（重要）

### 4.1 基本原則

- **エラーを握りつぶさない**
    - 失敗したら原因を追い、正しく直す
    - AIが生成したコードでもエラーハンドリングは必須
- **lint等のエラーは回避策を探す**
    - 無効化して削除はNG（例外運用を作らない）
    - ルールに問題があれば、ルール自体を見直す
- **AIを「ジュニア開発者」として扱う**
    - 生成されたコードは必ずレビューする
    - 意図を理解してから採用する
    - 間違いを見つけたら修正を指示する

### 4.2 変更の進め方（推奨手順）

1. **ロジックを組む際は広い視点で別のやり方はないか考える**
    - まず「目的に対して複数の実現方法」を列挙してから、最小で安全な案を選ぶ
    - 例：分割（関数/層/責務）、早期return、データ構造の変更、境界（I/O分離）の見直し、既存機能の再利用
2. **まずテスト用に関数（またはテストケース）を作り、期待する動作を定義する**
3. **テストが通るように実装・改善する**
4. **必要に応じて最適化・可読性改善のリファクタを行う（ただし目的を混ぜない）**
5. 完成系を移動

### 4.3 効果的なプロンプティング

### コンテキストの提供

- **豊富なコンテキストを与える**
    - プログラミング言語、フレームワーク、ライブラリ
    - エラーメッセージ（完全なもの）
    - 期待される動作と実際の動作の差分
    - 技術的制約（実行環境、APIバージョン、パフォーマンス要件等）
- **具体的で明確な指示**
    - 曖昧な「動かない」ではなく、具体的な症状を記述
    - 期待する出力形式を明示（JSON、パッチ、テスト付き実装等）
    - 例：「Node.js 18環境で、10,000までの素数判定を最適化した関数を書いて」

### 段階的アプローチ

- **複雑なタスクは分割する**
    - 一度に全部やらせず、小さなステップに分ける
    - 各ステップで検証してから次へ
- **Few-shot prompting（例示）の活用**
    - 期待する出力スタイルの例を2-3個提供
    - コーディング規約やパターンの例を示す
- **Chain-of-thought（段階的推論）**
    - 「ステップバイステップで考えて」と指示
    - 複雑な問題の解決に有効

### AIテンプレート化（推奨）

AIへの依頼を構造化：

```
## 目的
[何を実現したいか]

## 制約
- 触って良いファイル: [範囲を明示]
- 触ってはいけないもの: [禁止事項]
- 使用技術: [言語、フレームワーク等]
- パフォーマンス要件: [必要なら]

## 期待する出力
- [ ] パッチ形式で差分を提示
- [ ] テストコードも含める
- [ ] コメントで変更理由を説明

## 追加指示
- 最小差分で変更
- リファクタは別PRで
- まずテスト追加→実装の順で

```

### 4.4 差分の安全装置

- **「最小差分で」を明示**
    - 不要な変更を避ける
    - 既存コードへの影響を最小化
- **「リファクタ禁止」を指定**（必要に応じて）
    - 機能追加とリファクタは分ける
- **「まずテスト追加→実装」の順序を指定**
    - TDD的アプローチで安全性を確保

### 4.5 検証と品質チェック

- **最後に必ず実行する**
    - `lint` / `typecheck` / `test` を通す（CIでも強制する）
    - 手元で動作確認してからコミット
- **段階的な改善**
    - プロンプトを反復的に改善
    - 最初から完璧を求めず、対話的に洗練
- **セキュリティレビュー**
    - AI生成コードも必ずセキュリティ観点でレビュー
    - 入力検証、認証・認可、機密情報の扱いを確認

### 4.6 AIツールの使い分け

- **IDE統合型**（Cursor, GitHub Copilot等）
    - インライン補完、関数生成に最適
    - 開発フローに自然に統合
- **CLI型**（Claude Code, Gemini CLI等）
    - 複数ファイルにまたがる変更に有効
    - バッチ処理的なタスクに適している
- **エージェント型**（Jules, Antigravity等）
    - 複雑なマルチステップタスクに対応
    - 計画→実行→検証のサイクルを自律実行

**重要**: ツールに使われるのではなく、ツールを使いこなす開発者であり続ける

---

## 5. ドキュメント整備（AIが迷わない入口）

### 5.1 READMEの配置戦略

- **全てのディレクトリに `README.md` を設置**
    - 目的（このディレクトリは何のためにあるか）
    - スコープ（何が含まれ、何が含まれないか）
    - 入口ファイル（どこから読み始めるか）
    - 実行方法（どうやって動かすか）
    - よくあるタスク（典型的な操作手順）
    - 罠・注意点（ハマりやすいポイント）

### 5.2 "まず読ませる"セット（推奨）

- **`README.md`**：目的・入口・実行方法
    - プロジェクトの概要
    - クイックスタートガイド
    - 主要な構成要素へのリンク
- **`CONTRIBUTING.md` or `AGENTS.md`**：作業ルール・規約・コマンド
    - 開発ワークフロー
    - コーディング規約
    - AI使用時のガイドライン
    - よく使うコマンド一覧
- **`ARCHITECTURE.md`**：依存関係・契約・全体像
    - システムアーキテクチャ図
    - 主要コンポーネントの責務
    - データフロー
    - 技術スタックと選定理由

### 5.3 READMEのメンテナンス

- **READMEは太らせすぎない**
    - 詳細は `/docs` やADRへ逃がしてリンク
    - READMEは最小で新鮮に保つ（更新されないドキュメントは信頼を失う）
- **定期的な見直し**
    - 四半期ごとに古い情報を削除・更新
    - 新しいメンバーに読んでもらってフィードバックを得る
- **AIにドキュメントを生成させる**
    - 既存コードからREADME、コメントを生成
    - ただし必ず人間がレビュー・修正

### 5.4 「なぜ」を記録するドキュメント

ソフトウェアアーキテクチャの第二法則：**「Why」は「How」より重要**

### ADR（Architecture Decision Records）の重要性

ADRは、重要なアーキテクチャ決定とその背景を記録する構造化されたドキュメントです。

**ADRが必要な理由**：

- **知識の保存**：人は異動・退職する。決定の背景を失わないために
- **新メンバーのオンボーディング**：「なぜこうなってるの？」への回答
- **意思決定の透明性**：選択肢、トレードオフ、結果を明確化
- **将来の判断材料**：似た状況で過去の決定を参照できる
- **監査・コンプライアンス**：決定プロセスの証跡

**ADRを作成すべき時**：

- アーキテクチャに大きな影響を与える決定（技術スタック選定、データベース選択等）
- 非機能要件に関わる決定（セキュリティ、可用性、スケーラビリティ等）
- 複数の選択肢があり、トレードオフを検討した結果の決定
- 将来のメンバーが「なぜ？」と疑問に思いそうな決定

**ADRを作成しなくて良い時**：

- リスク・コスト・スコープが限定的な決定
- すでに標準やポリシーで定められている決定
- 一時的な回避策、PoC、実験的なもの
- 単一開発者の範囲で完結する小さな変更

**ADRの基本構造**：

```markdown
# ADR-001: [短い名詞句のタイトル]

## 日付
2026-01-22

## ステータス
提案中 / 承認済み / 却下 / 非推奨 / 置き換え済み

## コンテキスト（背景・課題）
どのような問題・課題があったのか？
技術的、ビジネス的、社会的な要因は何か？
中立的な事実を記述する

## 決定（What We Will Do）
どの選択肢を採用するか
能動態で明確に記述：「我々は〜を採用する」

## 検討した代替案
- 選択肢A：メリット / デメリット
- 選択肢B：メリット / デメリット
- 選択肢C：メリット / デメリット

## 結果（Consequences）
この決定により何が起こるか？
ポジティブな結果、ネガティブな結果、中立的な結果すべて記載
技術的、運用的、ビジネス的な影響

## 信頼度（オプション）
この決定に対する確信度（低/中/高）
低い場合は将来の再検討の可能性を示唆

```

**ADRの運用ルール**：

- **コードに近い場所に配置**：`/docs/adr/` または各リポジトリのルート
- **バージョン管理**：必ずGitで管理（変更履歴を追跡）
- **不変性**：承認後のADRは基本的に変更しない（新しいADRで置き換え）
- **簡潔に**：1-2ページ程度、要点を絞る
- **レビュープロセス**：PRでレビュー、チームで議論してから承認

**AI駆動開発でのADR活用**：

- AIに実装を依頼する際、関連ADRを必ずコンテキストに含める
- 「ADR-005に基づいて実装して」と明示
- AIが生成したコードがADRに準拠しているか確認

### インラインコメント

- **「なぜ」を書く**（「何を」はコード自体が語る）
    - 悪い例：`// iをインクリメント`
    - 良い例：`// キャッシュミス時のリトライのため2回実行`
- **複雑なロジックの意図を明確に**
    - アルゴリズムの選択理由
    - 特殊なエッジケースへの対処理由
- **タグの活用**
    - `TODO`: 将来やるべきこと（担当者・期限も記載推奨）
    - `FIXME`: 既知の問題、暫定対処
    - `HACK`: 本来の解決策ではない回避策
    - `WHY`: 特に「なぜこうしたか」を強調したい場合

---

## 6. 品質ゲート（自動化で守る）

### 6.1 CI/CDパイプライン

- **フォーマットは自動化する**
    - 例：pre-commit / lefthook / husky 等
    - コミット前に自動整形、手動の手間を削減
- **CIでFailしたらマージ不可**
    - 例外を作らない（運用が壊れる）
    - ステータスチェック必須化
    - 全テストパス + lint通過 + typecheck通過が必須
- **段階的テスト実行**
    - PR作成時：ユニットテスト + lint
    - マージ前：統合テスト
    - デプロイ前：E2Eテスト

### 6.2 コード品質の維持

- **CODEOWNERS等で責任範囲を明確化する**
    - レビューが安定する
    - 適切な専門家が必ずレビュー
- **自動化ツールの活用**
    - SonarQube、Code Climate等でコード品質を計測
    - セキュリティスキャン（Snyk、Dependabot等）
    - カバレッジレポートの可視化
- **依存関係更新の方針を決める**
    - まとめ方・頻度・安全性
    - セキュリティパッチは即座に適用
    - メジャーバージョンアップは計画的に

### 6.3 継続的改善

- **メトリクスの追跡**
    - ビルド時間、テスト実行時間
    - デプロイ頻度、変更失敗率
    - 平均修復時間（MTTR）
- **定期的なレトロスペクティブ**
    - うまくいったこと、改善点を議論
    - プロセスの継続的改善
- **ドッグフーディング**
    - 自分たちのツールを自分たちで使う
    - 痛みを感じることで改善が進む

---

## 7. AI駆動開発の成功パターン

### 7.1 人間とAIの協働

- **AI Powered Execution with Human Oversight**
    - AIが詳細な作業計画を作成
    - AIが不明点を積極的に質問
    - 重要な決定は人間が行う（AIは提案まで）
- **Dynamic Team Collaboration**
    - AIがルーチンタスクを処理している間、チームはリアルタイムで問題解決、創造的思考、迅速な意思決定に集中

### 7.2 学習と成長

- **AI活用でのスキルアップ**
    - ジュニア開発者がAIを使いながら学ぶ
    - シニアエンジニアの思考パターンを早く身につける
    - 知らない技術領域への参入障壁を下げる
- **コミュニティからの学習**
    - 効果的なプロンプトはコミュニティでシェア
    - Hacker News、Twitter等で最新テクニックをキャッチアップ
    - 自分なりのプロンプトライブラリを構築

### 7.3 注意すべき落とし穴

- **ツール過多に陥らない**
    - 1-2個のツールから始める
    - 慣れてから追加を検討
- **コンテキスト理解の不足**
    - AIはプロジェクト固有の文脈を知らない
    - 十分な背景情報を常に提供
- **過信しない**
    - AIは間違える（ハルシネーション）
    - 「わからない」と言う選択肢を与える
    - 重要な判断は必ず人間が検証

---

## 8. まとめ：AI時代の開発者として

AI駆動開発は、開発速度を上げ、イノベーションを促進し、コード品質を向上させる強力な手段です。しかし、**AIはツールであり、開発者がドライバーである**ことを忘れてはいけません。

**成功のための心構え**：

- 小さく始める（1つのツール、1つの実践から）
- 反復的に改善する（プロンプトも、プロセスも）
- チームで学び合う（知見を共有する）
- 継続的に適応する（技術は進化し続ける）

**最も重要なこと**：

AIに置き換えられるのを恐れるのではなく、AIを使いこなす開発者になること。適応を拒む開発者こそが最もリスクが高い。今こそ、実験し、学び、AIを自分のワークフローに統合する時です。

---

## 参考リソース

- [Anthropic: Context Engineering](https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)
- [Google: AI Coding Assistant Best Practices](https://cloud.google.com/blog/topics/developers-practitioners/five-best-practices-for-using-ai-coding-assistants)
- [Practical Test Pyramid - Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html)
- [Pull Request Best Practices](https://graphite.com/blog/pull-request-best-practices)
- [Prompt Engineering Guide](https://www.promptingguide.ai/)

---

**このドキュメントは生きています。改善点があれば随時更新していきましょう。**